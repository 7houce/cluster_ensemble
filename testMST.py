from MSTClustering import MSTClustering
import numpy as np
import os
import matplotlib.pyplot as plt

_colors = ['dodgerblue', 'black', 'darkorange', 'magenta', 'darkcyan', 'goldenrod',
           'mediumslateblue', 'khaki', 'saddlebrown', 'crimson']


def mst_with_cutoff(nidpath, pospath, savepath, distype='nid', cutoff_type='rate',
                    cutoff_upper=0.9, cutoff_lower=0.1, interval=0.05):
    """
    Do MST clustering on given library of solutions
    Used for deciding the suitable cutoff value which will be utilized in the MST selection procedure

    Parameters
    ----------
    :param nidpath: path where distance matrix stored
    :param pospath: path where positions (generated by MDS or other embedding approaches) stored
    :param savepath: path where the visualizations of clustering result stored
    :param distype: type of distance used
    :param cutoff_type: type of parameter 'cutoff', maybe 'threshold' or 'rate'
    :param cutoff_upper: upper bound of cutoff value
    :param cutoff_lower: lower bound of cutoff value
    :param interval: interval of cutoff value

    """
    nidpath = os.path.expanduser(nidpath)
    for f in os.listdir(nidpath):
        # deal with OSX's '.DS_Store'
        if f.startswith('.'):
            continue
        fullpath = os.path.join(nidpath, f)
        if os.path.isfile(fullpath):
            fname = os.path.splitext(f)
            filename = fname[0].split('_' + distype)[0]
            dataset_name = filename.split('_')[0]
            if not os.path.isdir(savepath + dataset_name):
                os.mkdir(savepath + dataset_name)

            # read distances and positions
            distanceMatrix = np.loadtxt(fullpath, delimiter=',')
            pos = np.loadtxt(pospath + filename + '_mds2d.txt', delimiter=',')

            # do MST clustering by setting 'cutoff' between [cutoff_lower, cutoff_upper] with given interval
            cur_cutoff = cutoff_lower
            while cur_cutoff <= cutoff_upper:
                if cutoff_type == 'threshold':
                    mstmodel = MSTClustering(cutoff_scale=cur_cutoff, min_cluster_size=2, metric='precomputed', approximate=False)
                else:
                    mstmodel = MSTClustering(cutoff=cur_cutoff, min_cluster_size=2, metric='precomputed', approximate=False)
                mstmodel.fit(distanceMatrix[0:-4, 0:-4])
                clusters = np.unique(mstmodel.labels_)
                fig = plt.figure(1)
                plt.clf()
                for i in clusters:
                    xs = pos[0:-4][mstmodel.labels_ == i, 0]
                    ys = pos[0:-4][mstmodel.labels_ == i, 1]
                    ax = plt.axes([0., 0., 1., 1.])
                    if i != -1:
                        plt.scatter(xs, ys, c=_colors[((int(i) + 1) % len(_colors))], label='Clusters-' + str(i))
                    else:
                        plt.scatter(xs, ys, c=_colors[((int(i) + 1) % len(_colors))], label='Outliers')
                plt.scatter(pos[-4:-1, 0], pos[-4:-1, 1], c='blue', marker='D', label='Consensus')
                plt.scatter(pos[-1:, 0], pos[-1:, 1], c='red', marker='D', label='Real')
                plt.legend(loc='best', shadow=True)
                plt.savefig(savepath + dataset_name + '/' + filename + '_afterMST' + '_' + str(cur_cutoff) + '.png', format='png', dpi=240)
                cur_cutoff += interval
    return

# autoClustering('Results/MST/nid/', 'Results/MST/pos/', 'Results/MST/mst/')
